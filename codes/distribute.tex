\section{A Parallel Solution for Answering $k$-UNN and $k$-UANN Queries with Distributed U-trees}
\label{sec:distribute}	

To support queries on large uncertain graphs, we extend our previous solution to distributed setting, in which we use a cluster of machines (a.k.a cluster) under the master-slave model.
We first discuss the two major challenges in Section \ref{sec:master-slave}, and then present our solutions, including distributed U-tree construction (Section \ref{sec:dutree}) and statistically iterative repartitioning (SIR) method (Section \ref{sec:SIR}).

\begin{figure*}[!t]
	\centering
	\npart
	\subfigure[]{
		\includegraphics[width=0.27\linewidth]{figs/Master_slaves_framework_offline.pdf}%
		\label{fig:ms1}}
	\hfil
	\subfigure[]{
		\includegraphics[width=0.31\linewidth]{figs/Master_slaves_framework_online.pdf}%
		\label{fig:ms2}}
	\hfil
	\subfigure[]{
		\includegraphics[width=0.38\linewidth]{figs/SIR_flow.pdf}%
		\label{fig:SIR}}
	\caption{An overview of our parallel solution: (a) offline phase (b) online phase (c) overview of SIR method, illustrated by a $k$-UANN query with input $S$=$\{C,E\}$ from Fig. \ref{fig:Q1}.}
	\label{fig:master_slave}
\end{figure*}

\subsection{Two major challenges}
\label{sec:master-slave}

In our master-slave model, the master (coordinator) first assigns different bags (augmented uncertain subgraphs) of the U-tree to different slaves (machines) in the offline phase. For example, the master assigns the bags $\beta$ and $\gamma$ to slave 1 in Fig.~\ref{fig:master_slave}.
%
In the online phase, the master assigns single-pair expected distance queries to the slaves, then the slaves evaluate these queries separatively, and finally the master aggregates the results from the slaves to answer the $k$-UNN or $k$-UANN queries. 
%
During the offline and online phases, there are two major challenges:

{\bf Communication overhead. } Some queries require the bags which are scattered in different slaves. This incurs overhead since the slave needs to communicate with other slaves which contain the required bags in order to evaluate the distance. 
For example in Fig.~\ref{fig:master_slave}, it takes 3 bags ($\alpha$, $\beta$, and $\gamma$) to evaluate $d(E,A)$. However, there are only two bags ($\beta$ and $\gamma$) within slave 1. As such, slave 1 needs to communicate with slave 2 in order to obtain enough bags ($\alpha$). This communication cost can be high and it affects the efficiency performance in distributed algorithms. 
In this paper, we focus on cases where duplicates are not allowed in the cluster, which is a popular assumption for distributed graphs \cite{kassiano2016mining,cheng2016distr}. Thus each bag in $\mathcal{T}$ can only be assigned to one slave.

{\bf Machine overloading. } Due to the different popularity of the query nodes from $k$-UNN or $k$-UANN, the workloads of different slaves vary.  
%If the $k$-NN query $q_k()$for node $B$ is always issued by the users, slave 1 is always busier than slave 2. 
In the distributed setting, the slowest slave becomes the bottleneck. In an unbalanced cluster, some slaves are busy while the others become totally idle. In this case, adding machines in the cluster cannot help improve the performance.
For example, more queries for nearest restaurants can be issued from business areas rather than rural areas on a road network. 
Thus workloads should be balanced to overcome it. %reduce the query time.

However, these two goals usually conflict with each other. From the point of machine overloading, 
%Once the same $k$-NN query, e.g., for node $B$, is frequently issued, then 
it is better to scatter the popular bags to different machines in order to balance the query workloads on each slave. 
However, it leads to higher communication overhead 
%because of the higher cost to collect enough augmented uncertain subgraphs for answering a single query.
%assign augmented uncertain subgraphs which can avoid communication 
since bags are separated into more machines.
From the point of communication overhead, it is better to assign as many bags as possible to each slave, in order to minimize the slave-slave communication. However, each slave may contain several popular bags and thus, is extremely busy than other slaves.

%\vsp
\subsection{Distributed U-tree } 
\label{sec:dutree}

To deploy U-tree in several machines, we consider both offline and online phases. In the offline phase, we construct U-tree in parallel (Fig.~\ref{fig:overview-sir}a), and in the online phase, we query U-tree from several machines to answer the $k$-UNN or $k$-UANN query (Fig.~\ref{fig:overview-sir}b). 

\textbf{Offline phase. } 
When constructing U-tree from several slaves, we parallelize the process by reducing the nodes whose degree is smaller than three. 
For any node $v$ with degree as two (with neighbors $u$ and $w$), we reduce the triple $\langle u,v,w\rangle$ into $\langle u,w\rangle$ by probability propagation. 
In this process, a lock is secured on $\langle u,v,w\rangle$, so that the three nodes cannot be processed by other slaves. 
Similarly, for any node $x$ with degree as one (with neighbor $y$), we reduce the tuple $\langle x,y\rangle$ into $\langle x\rangle$ by probability propagation. A lock is secured on $\langle x,y\rangle$ in this process.

To reduce the triples and tuples iteratively, we maintain global and local tables in the distributed system. In the master, we maintain a global table to record the cross edges, which are distributed across several slaves. In each slave, we maintain a local table to record the degree of each node in order to find the next node to be reduced, whose degree is smaller than 3. Note that only the nodes within cross edges can be affected by the other slaves and thus need to be synched.
For example, if the tuple $\langle x,y\rangle$ is a cross edge (e.g., node $x$ in slave 1 and node $y$ in slave 2, and degree of node $x$ is 1), we delete node $x$ from slave 1 and generate a augmented uncertain subgraph in slave 2. The cross edge table and degree table are updated accordingly. In this manner, the augmented uncertain subgraphs $\bar{b_i}$ generated in several machines are linked into a distributed U-tree. The process is shown in \textit{Decom.} in Fig.~\ref{fig:overview-sir}a.

Then we propagate the probabilities in the same manner of step $B$ in Section \ref{sec:algorithm} to customize the augmented uncertain subgraphs $\bar{b_i}$ into $b_i$ (cf. \textit{Cust.} in Fig.~\ref{fig:overview-sir}a). In this process, the master coordinates the propagation by the global table, which records the location of each bag in the distributed U-tree. Note that a slave $a_i$ may contain several bags.
%$; that is, $s_i=s_j$ is allowed in \figname \ref{sec:algorithm}a. 

\textbf{Online phase. } 
Given a $k$-UNN or $k$-UANN query, we decompose it into a set of expected distance queries $d(s,t)$ and assign each query to the slave $a_i$ which contains the essential set of bags $A(s,t)$. Then as shown in Fig.~\ref{fig:overview-sir}b, the slave answers all $d(s_{i,j},t_{i,j})$ within $a_i$ in the manner of Section \ref{sec:utree}. Note that there will be communications among different slaves in this process, since $A(s,t)$ may be distributed in several slaves. Here we assign $d(s,t)$ to the slave that contains the majority of $A(s,t)$, which is recorded in the global table generated in the offline phase. Finally, the expected distances are aggregated to answer the query.

As stated, the distribution of the U-tree bags may affect the querying performance. Thus we introduce a method to balance the workloads while minimizing the communication overhead, by analyzing the correlations in the distributed U-tree. 
\begin{figure}[!t]
	\centering
	\includegraphics[width=\linewidth]{figs/overview_sir.pdf}
	\caption{\npart Overview of answering the $k$-UNN or $k$-UANN query by distributed U-tree, with (a) offline phase: construct U-tree in parallel (b) online phase: query distributed U-tree to answer the query.}
	\label{fig:overview-sir}
\end{figure}

%\vsp
\subsection{Statistically Iterative Repartitioning}
\label{sec:SIR}
In this section, we develop the statistically iterative repartitioning (SIR) method, which explores the statistics in the query log (query-count), in order to achieve the good trade-off between communication overhead and machine overloading.

As mentioned in Section \ref{sec:master-slave}, one major issue for distributed setting to be scalable is the communication overhead in which bags are transferred between different slaves.
%To address this issue, we consider the $k$-NN query of node $B$ as an example. 
%Observe from Table \ref{dt1}, some augmented uncertain subgraphs, e.g., $\beta$ and $\gamma$, are typically correlated
We call two augmented uncertain subgraphs are correlated if they often appear simultaneously in the set of accessed bags. Then 
%once the $k$-NN query of node $B$ is always issued, 
it is better to assign these bags into the same slave to avoid communication cost. 

In the following, we quantify this correlation relationship among different bags, given history statistics of query nodes (e.g. query-count in Fig.~\ref{fig:SIR}) in the system. Here we use query-count as the number of times of each node appearing in the queried nodes, which is easy to be maintained in most logging systems.

\begin{defi}
	Given the frequency $f_{s,t}$ of $d(s,t)$, the correlation value between two bags $b_1$ and $b_2$, is defined as:
	\begin{equation}
	%\hspace{-9mm}
	\Theta(b_1,b_2)=\sum\limits_{\substack{s,t\in V \\ s\neq t}}f_{s,t} \mathbbm{1}(x_1) \mathbbm{1}(x_2),\ 	\mathbbm{1}(x_i) =\begin{cases}
	1,b_i\in A(s,t); \\
	0,\text{otherwise.}
	\end{cases}
	\end{equation}
\end{defi}
Here $\mathbbm{1}(x_i)$ denotes the indicator function for the statement $x_i: b_i\in A(s,t)$. 
\begin{figure}[!t] {
		\npart
		\subfigure[]{ 
			\centering
			\includegraphics[width=0.48\linewidth]{figs/BeijingQueries.pdf} 
			\label{fig:BJquery} %% label for second subFigure 
		}%
		\subfigure[]{  
			\centering 
			\includegraphics[width=0.51\linewidth]{figs/HKQueries.pdf}
			\label{fig:HKquery} %% label for first subFigure 
		}% 		
		\caption{Illustration of taxi pick-up points from (a) May 2009 of Beijing (b) May 2010 of Hong Kong. Blue points are the queries from 12am to 6am, yellow point from 6am to 12pm, red points from 12pm to 6pm, and green points from 6pm to 12am.}
		\label{fig:query}
	}
\end{figure}
We construct the correlation graph (cf. Fig.~\ref{fig:SIR}) based on the value $\Theta(b_1,b_2)$ for different pairs of bags, for example, $\Theta(\alpha,\beta)=28$. To make the correlation graph clear, we omit the edges with correlation value smaller than 10 in Fig.~\ref{fig:SIR}. 
We attach the calculation for this example as below.

\input{files/table_SFtable}

First, based on the query logs in Fig.~\ref{fig:SIR}, the frequency of each $d(s,t)$ can be calculated, which is shown in Table \ref{tab:durs}. We also attach the accessed bags $A(s,t)$ for each $d(s,t)$ for better demonstration. 
%For example, the frequency of $d(A,B)$ is the sum of the frequency of $q_k(A)$ and that of $q_k(B)$. 
Note that we do not need to cache these data, since the frequency values can be calculated when they are needed. 
With the frequency of each $d(s,t)$, the correlation values between each pair of bags are calculated, e.g., the correlation value between $\gamma$ and $\epsilon$ equals the frequency of $A(A,F)$.

%Since our ultimate goal is to assign different set of augmented uncertain subgraphs to the slaves (cf. \figname \ref{fig:SIR}), 
To better capture the cohesiveness among the bags, we analyze the correlation based on \textit{modularity} \cite{newman2004analysis}. 
%Compared to other methods like minimum-cut method \cite{newman2004detecting}, our method can . 
We denote $P(b)$ as the set of bags that are within the same slave as the bag $b$. For example, $P(\alpha)=\{\alpha, \delta,\epsilon\}=P(\delta)$ in Fig.~\ref{fig:master_slave} since these three bags are assigned to slave 1. Mathematically, we find $P$ to maximize the following optimization problem \cite{newman2004analysis}.
%
\begin{equation}
%\hspace{-7mm}
\label{equ:community}
\begin{aligned}
&
& & \max\limits_P \sum_{b_1, b_2\in \mathcal{B}}\Big[\Theta(b_1,b_2)-\frac{k(b_1)k(b_2)}{2m}\Big]\mathbbm{1}(P(b_1)=P(b_2)) %\\
%& \text{s.t.} & & \forall b\in \mathcal{B}: |P(b)|\leq h
\end{aligned}
\end{equation}

Following the definition in \cite{newman2004analysis}, the two variables are $k(b)=\sum_{\hat{b}\in \mathcal{B}}\Theta(b, \hat{b})$ and $m=\frac{1}{2}\sum_{b_i,b_j \in \mathcal{B}}\Theta(b_i,b_j)$. 
This optimization problem aims to put two bags which have high correlation to the same slave. However, there is one drawback for this formulation. If many bags are highly correlated,
%(cf. \figname \ref{})
it is possible for the above optimization algorithm to assign many bags to one slave, which leads to the machine overloading problem. Therefore, we impose the following constraint which prohibits the number of bags in each slave to be bigger than $h\cdot |\mathcal{B}|$. Mathematically, we have:
\begin{equation}
\forall b\in \mathcal{B}: |P(b)|\leq h\cdot |\mathcal{B}|
\label{equ:hv}
\end{equation}

For a smaller $h$, each slave contains fewer bags, leading to higher communication cost but smaller machine overloading effect. Therefore, there is a trade-off for choosing the parameter $h$. We will empirically evaluate the effect of $h$ in the experiments. 
%In experiment, we use sampling-based method to automatically tune this parameter $h$. 
In practice, the number of machines usable can be another constraint, limited by the budget. There are two points to handle it when applying Equation \ref{equ:community} and \ref{equ:hv}. First, $h$ cannot be too small. Second, the searching space need to be narrowed, to maximize the modularity with the given number of slaves.

Since the correlation analysis is an offline phase, SIR method only updates the U-tree partitions for each slave at some given time points, e.g., update the cluster when the query trends change. On a road network, this time point can be the morning/evening peak time, e.g., Example \ref{exa:sir}. The cluster manager can use the history statistics or query trend aggregation methods \cite{poppe2017greta} to help determine the time points to update the bags assignment.
We show in the experimental evaluations that re-partitioning the uncertain graph and assigning bags according to the correlation results are essential for efficient query processing.

\begin{exa}
	Searching for top-$k$ nearest taxis is a typical application for both $k$-UNN and $k$-UANN queries, considering the uncertain traffic flow and GPS error of the user. In Fig. \ref{fig:query}, we treat each taxi pick-up point as a query to analyze the query trends, e.g., the taxi pick-up point is the user's location where the query is issued. 
	As shown in Fig.~\ref{fig:query}, the popular area being searched keeps changing in different time periods. 
	%people trend to search bushiness areas before the evening peak time, but residential areas after that time. 
	More queries come from eastern Beijing and northern Hong Kong at night (blue and green nodes), which is opposite to their day-time pattern. 
	As the hotspot data have changed, we need to update the bags assignment in the cluster. 
	%after handling a number of queries (say 10000).
	\label{exa:sir}
\end{exa}